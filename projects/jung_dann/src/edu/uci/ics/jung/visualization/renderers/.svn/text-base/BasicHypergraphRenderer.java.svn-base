package edu.uci.ics.jung.visualization.renderers;

import java.awt.Color;
import java.util.ConcurrentModificationException;

import edu.uci.ics.jung.algorithms.layout.Layout;
import edu.uci.ics.jung.graph.Graph;
import edu.uci.ics.jung.graph.Hypergraph;
import edu.uci.ics.jung.graph.PseudoHypergraph;
import edu.uci.ics.jung.visualization.RenderContext;

/**
 * This class implements a basic hypergraph renderer.
 * 
 * @author Andrea Francke, Olivier Clerc
 * @param <V> Type of hypervertex 
 * @param <E> Type of hyperedge
 */
public class BasicHypergraphRenderer<V,E> extends BasicRenderer<V,E> {

	/**
	 * Construct a new basic hypergraph renderer that uses the basic
	 * hyperedge and hypervertex renders.
	 */
	public BasicHypergraphRenderer() {
		super();
		
		setVertexRenderer(new BasicHypervertexRenderer<V,E>());
		setEdgeRenderer(new BasicHyperedgeRenderer<V,E>());
	}
	
	/**
	 * Render a hypergraph.
	 */
	public void render(RenderContext<V, E> renderContext, Layout<V, E> layout) {
		
		// get graph from layout
		Graph<V,E> g = layout.getGraph();
		
		// get pseudo-hypergraph
		if(!(g instanceof PseudoHypergraph))
			throw new Error("renderer requires pseudo-hypergraph");

		Hypergraph<V, E> hg = ((PseudoHypergraph<V,E>) g).getHypergraph();

		// paint all the edges
        try {
        	for(E e : hg.getEdges()) {
		        renderEdge(
		                renderContext,
		                layout,
		                e);
		        renderEdgeLabel(
		                renderContext,
		                layout,
		                e);
        	}
        } catch(ConcurrentModificationException cme) {
        	renderContext.getScreenDevice().repaint();
        }
		
		// paint all the vertices
        try {
        	for(V v : hg.getVertices()) {

		    	renderVertex(
		                renderContext,
                        layout,
		                v);
		    	renderVertexLabel(
		                renderContext,
                        layout,
		                v);
        	}
        } catch(ConcurrentModificationException cme) {
            renderContext.getScreenDevice().repaint();
        }
	}

	/**
	 * Returns for a non-negative index number a corresponding color. Different indices 
	 * result in human distinguishable colors. The color is available in a bright and dark
	 * version. Colors are generated by spiraling down into the middle of a color circle.
	 * 
	 * @param index A non-negative index number
	 * @param bright False for dark, True for bright
	 * @return The color
	 */
	static Color colorFromIndex(int index, boolean bright) {		
		float hue, saturation, brightness;
		final int STEPS = 6;
		
		// set brightness
		if(bright)
			brightness = 0.8f;
		else
			brightness = 0.5f;

		// set hue				
		hue = (float) (index % STEPS) / (float) STEPS;
		
		// set saturation
		saturation = 1 / (((float) (index / STEPS)) + 1);
		
		return new Color(Color.HSBtoRGB(hue, saturation, brightness));
	}
	
	/**
	 * Return the index of a hyperedge in a hypergraph. If the hyperedge is not contained in the
	 * hypergraph, -1 is returned.
	 * 
	 * @param hg A hypergraph
	 * @param edge An edge
	 * @return The index
	 */
	static <V,E> int indexOfHyperedge(Hypergraph<V,E> hg, E edge) {
		int result = -1;
		for(E currentEdge : hg.getEdges()) {
			result++;
			if(edge.equals(currentEdge))
				return result;
		}
		
		return -1;
	}

}